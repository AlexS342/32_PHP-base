
/*
 Не плохая статья про PDO
"Почему стоит пользоваться PDO для работы с базой данных"
https://habr.com/ru/post/137664/
 */

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//ПОДКЛЮЧЕНИЕ
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 $pdo = new PDO('sqlite:database.db');                          /*Подключаемся в БД, если БД не, то она будет создана */

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//СОЗДАНИЕ ТАБЛИЦИ
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$query = 'CREATE TABLE `students` (                              /*Сохраняем в переменную команду для создания таблицы "students" */
            id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,       /*поле "id", INTEGER - тип integer, NOT NULL - не может быть пустым, PRIMARY KEY - поле с индинтификатором,  AUTOINCREMENT - при добавлении новой строки автоматически увеличивается на один*/
            name VARCHAR(100) NOT NULL                           /*поле "name", VARCHAR(100) - строка максимум 100 символов, NOT NULL - не может быть пустым */
        )';
$statement = $pdo->query($query);                                /*Создаем таблицу; $pdo->query($query) - в БД $pdo методом query() выполняем команду $query */

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//ДОБАВЛЕНИЕ СТРОКИ
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$studentName = "Абрам Курхнев";

                    /*в БД $pdo методом exec() отправляем команду в таблицу,
                    INSERT INTO `students` добавляем данные в таблицу  students,
                    (`name`) скобках указываем через запятую поля, в которые добаляем значения,
                    VALUES данные, которые хотим добавит в таблицу
                    ('$studentName') скобках указываем через запятую данные, которые добавляем в таблицу
                    */
$affectedCount = $pdo->exec("INSERT INTO `students` (`name`) VALUES ('$studentName')");
echo "<pre>";
var_dump($affectedCount); /*вернет количество измененных строк (строка добавится, но var_dump не выведет ее)*/
echo "</pre>";

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//УДАЛЕНИЕ СТРОКИ
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    /*в БД $pdo методом exec() отправляем команду в таблицу,
                    DELETE FROM `students` удалить строку из таблицы students,
                    WHERE id = 2 поле id должно быть равно 2
                    ! удаляем строку в таблице студент, у которой поле id равен двум
                    */
$affectedCount = $pdo->exec("DELETE FROM `students` WHERE id = 2");
echo "<pre>";
var_dump($affectedCount); /*вернет количество измененных строк (строка удалится, но var_dump не выведет ее)*/
echo "</pre>";

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//ИЗМЕНЕНИЕ ДАННЫХ
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    /*в БД $pdo методом exec() отправляем команду в таблицу,
                    UPDATE `students` изменяем значение полей в таблице students,
                    SET указывает в каких полях меняютс значения
                    name = 'Джон Конер' в поле name меняем значение на 'Джон Конер'
                    WHERE id = 3 поле id должно быть равно 3
                    ! после SET можно через запятую указать несколько полей
                    */
$affectedCount = $pdo->exec("UPDATE `students` SET name = 'Джон Конер' WHERE id = 3");
echo "<pre>";
var_dump($affectedCount); /*вернет количество измененных строк (значение в поле name изменится, но var_dump не покажет этого)*/
echo "</pre>";

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//ВЫБОР ДАННЫХ (в переменной хранится только запрос, для получение нужно использовать fetch
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/*
в БД $pdo методом exec() отправляем команду в таблицу,
SELECT выбрать данные
    * - всю строку
    id, name - данные из полей id и name
    id as key, name as user - указываем как переименовать при результирующей выдаче (в таблице поля не переименуются)
FROM `students` - в таблице students
WHERE - указывает на критерии выбора данных (если не указать, то выберет всю таблицу
    id = 4 - строку в которой поле id = 4
    name LIKE "%Джон%" - не строгий поиск, вернет все строки у которых в поле name есть значение Джон
 */
/*
 !!! ВЫБРАНЫЕ ДАННЫЕ ПРИ ПОМОЩИ КОМАНДЫ SELECT МОЖНО ПОЛУЧИТЬ МЕДОТОМ FETCH()
 !!! В ПЕРЕМЕННОЙ $affectedCount ПОКА ЕЩЕ НЕТ ЭТИХ ДАННЫХ В ПРИГОДНОМ ДЛЯ ЧТЕНИЯ ВИДЕ, там хранится PDOStatement
 */
$affectedCount = $pdo->query("SELECT * FROM `students`");
$affectedCount2 = $pdo->query("SELECT `id`, `name` FROM `students` WHERE id = 4");
$affectedCount3 = $pdo->query('SELECT id as key, name as user FROM `students` WHERE name LIKE "%Джон%"');
$affectedCount4 = $pdo->query('SELECT id, name FROM `students` WHERE name LIKE "%Вася%"');

//класс для демонстрации метода fetchObject
class Student {
    private int $id;
    private string $name;
    public function getId():int { return $this->id; }
    public function getName():string { return $this->name; }
}
//~~~~~~~~~~~~~~~~~~~~~~~~
// МЕТОД FETCH И ЕГО МОДИФИКАЦИИ
//~~~~~~~~~~~~~~~~~~~~~~~~
echo "<pre>";
print_r($affectedCount->fetchAll(PDO::FETCH_ASSOC));
print_r($affectedCount2->fetch(PDO::FETCH_NUM));
print_r($affectedCount3->fetch(PDO::FETCH_OBJ));
fetchObject - позволяет получить объект, но если в классе есть конструктор, то возникнут сложности
print_r($affectedCount4->fetchObject(Student::class));   //В скобках указываем имя класса 'Student' в ковычках или Student::class
echo $affectedCount4->fetchObject('Student')->getName();    // Получаем полноценный объект со всеми методами
echo "</pre>";
/*
!!! после получения всех строк методом fetch() в переменной остается null и для повторного получения данных нужно повторно выполнить SELECT
->fetchAll() - вернет все найденые строки ввиде массива с масивами, каждое поле сохранено дважды, с нумерованым и именованым крючем
->fetch() - вернет !!!первую из всех найденых строк ввиде массива каждое поле сохранено дважды, с нумерованым и именованым крючем
                    !!!каждый следующий fetch будет возвращать следующую из найденых строк
                    !!!если найденые строки закончатся, то вернет false
                    !!!УДОБНО ИСПОЛЬЗОВАТЬ В ЦИКЛЕ!
в скобках метода fetch можно казать в каком формате возвращать данные
    ->fetchAll(PDO::FETCH_ASSOC): возвращает массив с названиями столбцов в виде ключей
    ->fetchAll(PDO::FETCH_BOTH) (по умолчанию): возвращает массив с индексами как в виде названий стобцов, так и их порядковых номеров
    ->fetchAll(PDO::FETCH_BOUND): присваивает значения столбцов соответствующим переменным, заданным с помощью метода ->bindColumn()
    ->fetchAll(PDO::FETCH_CLASS): присваивает значения столбцов соответствующим свойствам указанного класса. Если для какого-то столбца свойства нет, оно будет создано
    ->fetchAll(PDO::FETCH_INTO): обновляет существующий экземпляр указанного класса
    ->fetchAll(PDO::FETCH_LAZY): объединяет в себе PDO::FETCH_BOTH и PDO::FETCH_OBJ
    ->fetchAll(PDO::FETCH_NUM): возвращает массив с ключами в виде порядковых номеров столбцов
    ->fetchAll(PDO::FETCH_OBJ): возвращает анонимный объект со свойствами, соответствующими именам столбцов
формат возврощаемых данных можно назначить по умолчанию еще при подключении к базе данных
    $pdo = new PDO('sqlite:database.db', null, null, [PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC]);
или изменить непосредствено в любом месте кода
    ->setFetchMode(PDO::FETCH_ASSOC);
 */
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//ПОДГОТОВЛЕНЫЕ ЗАПРОСЫ (Защита от инъекций в базу данных) (prepared statements)
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/*
Заместо query нужно использовать prepare вместе с placeholder, это защитит от инъекций
ЗАПРОС В БАЗУ ДАННЫХ ПРОИСХОДИТ В ТРИ ЭТАПА:
1) Составляем запрос prepare с placeholder
    *) !!! без placeholder метод prepare не дает защиты от инъекций, а выполняется как query
    $STH = $DBH->prepare("INSERT INTO folks (name, addr, city) values ($name, $addr, $city)");
    а)безымянные placeholders
    $STH = $DBH->prepare("INSERT INTO folks (name, addr, city) values (?, ?, ?)");
    б) именные placeholders
    $STH = $DBH->prepare("INSERT INTO folks (name, addr, city) values (:name, :addr, :city)");
2) При помощи bindParam назначаем передоваемые данные (!!!есть возможность сделать это в трерьем шаге при передаче в массиве)
    а) при использовании безымянного placeholders в методе bindParam() в первом значении указываем место для переменной (номер вопросительного знака)
        $STH->bindParam(1, $name);
        $STH->bindParam(2, $addr);
        $STH->bindParam(3, $city);
        !!! для повторного запроса $STH = $DBH->prepare(... повторно писать не нужно, тостаточно поменять данные в переменной и повторить отправку (пункт №3)
    б) при использовании именовонного placeholders в методе bindParam() в первом значении указываем имя placeholders
        $STH->bindParam('name', $name);
        $STH->bindParam('addr', $addr);
        $STH->bindParam('city', $city);
!!! для повторного запроса $STH = $DBH->prepare(... повторно писать не нужно, тостаточно поменять данные в переменной и повторить отправку (пункт №3)
3) Передаем запрос
    а), б) Независиво от типа placeholders передать запрос можно двумя способами
        I) Если использовали bindParam, то:
            $STH->execute();
        II) Если данные передаются массивом (показано напремере массива $data), то:
            $STH->execute($data);
            !!!$data[0] вставится на место первого placeholder’а, $data[1] — на место второго, и т.д.
            !!!Но будьте внимательны: если индексы в массиве сбиты, это работать не будет.
*/
//без placeholder метод prepare не дает защиты от инъекций

////Пример №1
$studentName = 'Кулёба Туриков';
//1)
$statements = $pdo->prepare("INSERT INTO students (name) values (?)");
//2)
$statements->bindParam(1, $studentName);
//3)
$statements->execute();
//Пример №2
$studentName = 'Дракула Кулаков';
//1)
$statements = $pdo->prepare("INSERT INTO students (name) values (:name)");
//2)
//$statements->bindParam('name', $studentName);
//3)
$statements->execute();
//Пример №3
//$arrStud = ['Данил Хитров'];
//1)
//$statements = $pdo->prepare("INSERT INTO students (name) values (:name)");
//3)
//$statements->execute($arrStud);



echo "<pre>";

echo '<p>pdo</p>';
var_dump($pdo);

echo '<p>pdo->errorInfo()</p>';
var_dump($pdo->errorInfo());

echo "</pre>";
